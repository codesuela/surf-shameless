// Generated by CoffeeScript 1.3.3
(function() {
  var MyBlacklist, WipeMode, myBlacklist, wipeMode,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MyBlacklist = (function() {
    var blacklistKeywords, blacklistUrls, customUrls, lastListUpdate, readyState, totalEnabled;

    blacklistUrls = [];

    customUrls = [];

    blacklistKeywords = [];

    lastListUpdate = 0;

    readyState = false;

    totalEnabled = 0;

    function MyBlacklist() {
      this.init();
    }

    MyBlacklist.prototype.isReady = function() {
      return readyState;
    };

    MyBlacklist.prototype.init = function() {
      var _this = this;
      console.log("init...");
      readyState = false;
      if (localStorage["myAvailableLists"] === "undefined" || localStorage["myAvailableLists"] === void 0) {
        this.getAvailableLists();
        return setTimeout(function() {
          return _this.init();
        }, 100);
      } else {
        console.log("enabling lists...");
        return this.loadEnabledLists();
      }
    };

    MyBlacklist.prototype.getBlacklist = function(type) {
      if (type === "urls") {
        return blacklistUrls;
      } else {
        return blacklistKeywords;
      }
    };

    MyBlacklist.prototype.isBlacklisted = function(string, type) {
      var lookupDir, s, _i, _len;
      string = string.toLowerCase();
      if (type === "url") {
        lookupDir = blacklistUrls;
      }
      if (type === "keyword") {
        lookupDir = blacklistKeywords;
      }
      for (_i = 0, _len = lookupDir.length; _i < _len; _i++) {
        s = lookupDir[_i];
        if (type === "url") {
          if (string.indexOf("http://www." + s) >= 0 || string.indexOf("http://" + s) >= 0) {
            return true;
          }
        } else if (type === "keyword") {
          if (string.indexOf(s) >= 0) {
            return true;
          }
        }
      }
      return false;
    };

    MyBlacklist.prototype.getAvailableLists = function(availableLists, refresh) {
      if ((localStorage["myAvailableLists"] === "undefined" && !availableLists) || refresh) {
        this.getLocalFile("lists/_available", this.getAvailableLists);
        return void 0;
      } else {
        return localStorage["myAvailableLists"] = JSON.stringify(availableLists);
      }
    };

    MyBlacklist.prototype.loadEnabledLists = function() {
      var availableLists, enabledLists, enabledListsIndex, listName, totalDisabled, _i, _len;
      blacklistUrls = [];
      blacklistKeywords = [];
      if (typeof localStorage["myCustomUrlList"] !== "undefined" && localStorage["myCustomUrlList"] !== "undefined") {
        blacklistUrls = JSON.parse(localStorage["myCustomUrlList"]);
      }
      if (typeof localStorage["myCustomKeywordList"] !== "undefined" && localStorage["myCustomKeywordList"] !== "undefined") {
        blacklistKeywords = JSON.parse(localStorage["myCustomKeywordList"]);
      }
      if (localStorage["enabledLists"] !== "undefined" && localStorage["enabledLists"] !== void 0) {
        console.log("enabledLists check");
        if (localStorage["myAvailableLists"] !== "undefined" && localStorage["myAvailableLists"] !== void 0) {
          console.log("myAvailableLists check");
          totalEnabled = 0;
          enabledLists = JSON.parse(localStorage["enabledLists"]);
          availableLists = JSON.parse(localStorage["myAvailableLists"]);
          console.log(availableLists);
          console.log(enabledLists);
          enabledListsIndex = 0;
          totalDisabled = 0;
          for (_i = 0, _len = availableLists.length; _i < _len; _i++) {
            listName = availableLists[_i];
            if (enabledLists[listName]) {
              enabledListsIndex++;
              totalEnabled++;
              console.log("loading list " + listName);
              this.loadList(void 0, listName, enabledListsIndex);
            } else {
              totalDisabled++;
            }
          }
          if (totalEnabled === 0 && totalDisabled > 0) {
            readyState = true;
          }
          console.log("end of list enabler");
          return true;
        }
      }
      return readyState = true;
    };

    MyBlacklist.prototype.loadList = function(listObject, name, index) {
      if (!listObject) {
        return this.getLocalFile("lists/" + name, this.loadList, name, index);
      } else {
        if (listObject.type === "urls") {
          blacklistUrls = blacklistUrls.concat(listObject.content);
        } else if (listObject.type === "keywords") {
          blacklistKeywords = blacklistKeywords.concat(listObject.content);
        }
        console.log(index);
        console.log(totalEnabled);
        console.log(index === totalEnabled);
        if (index === totalEnabled) {
          return readyState = true;
        }
      }
    };

    MyBlacklist.prototype.setListState = function(name, state) {
      var enabledLists;
      if (!localStorage["enabledLists"] || localStorage["enabledLists"] === "undefined") {
        enabledLists = {};
      } else {
        enabledLists = JSON.parse(localStorage["enabledLists"]);
      }
      if (state === true || state === false) {
        enabledLists[name] = state;
      }
      localStorage["enabledLists"] = JSON.stringify(enabledLists);
      console.log(localStorage["enabledLists"]);
      return this.loadEnabledLists();
    };

    MyBlacklist.prototype.getLocalFile = function(path, callback, var1, var2) {
      var xhr,
        _this = this;
      xhr = new XMLHttpRequest();
      xhr.open("GET", path, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          return callback(JSON.parse(xhr.responseText), var1, var2);
        }
      };
      return xhr.send();
    };

    return MyBlacklist;

  })();

  WipeMode = (function() {
    var badRedirects, firstBadTabTime, openTabs;

    openTabs = [];

    badRedirects = [];

    firstBadTabTime = void 0;

    function WipeMode(myBlacklist) {
      this.myBlacklist = myBlacklist;
      this.tabAdded = __bind(this.tabAdded, this);

      this.init();
    }

    WipeMode.prototype.init = function() {
      var _this = this;
      console.log("waiting for readyness");
      if (!myBlacklist.isReady()) {
        return setTimeout(function() {
          return _this.init();
        }, 100);
      } else {
        return this.wipeHistory(void 0, true);
      }
    };

    WipeMode.prototype.tabAdded = function(tabId, changeInfo, tab) {
      var currentUrl;
      currentUrl = tab.url;
      if (changeInfo.url) {
        currentUrl = changeInfo.url;
      }
      if ((myBlacklist.isBlacklisted(currentUrl, "url") || myBlacklist.isBlacklisted(tab.title, "keyword")) && openTabs.indexOf(tabId) === -1) {
        if (!firstBadTabTime) {
          firstBadTabTime = new Date().getTime() - 10000;
        }
        openTabs.push(tabId);
        return console.log(openTabs);
      } else if (!(myBlacklist.isBlacklisted(currentUrl, "url") || myBlacklist.isBlacklisted(tab.title, "keyword")) && openTabs.indexOf(tabId) >= 0) {
        this.tabClosed(tabId);
        return void 0;
      }
    };

    WipeMode.prototype.tabClosed = function(tabId) {
      var formerBadTab;
      formerBadTab = openTabs.indexOf(tabId);
      if (formerBadTab >= 0) {
        openTabs.splice(formerBadTab, 1);
        if (openTabs.length === 0) {
          this.wipeHistory(firstBadTabTime);
          return firstBadTabTime = void 0;
        }
      }
    };

    WipeMode.prototype.purgeBadUrl = function(url) {
      if (url.indexOf("http") === -1) {
        url = "http://" + url;
      }
      chrome.history.deleteUrl({
        url: url
      });
      if (url.indexOf("www") >= 0) {
        chrome.history.deleteUrl({
          url: url.replace("http://www.", "http://")
        });
        return console.log("purged " + (url.replace("http://www.", "http://")));
      } else {
        chrome.history.deleteUrl({
          url: url.replace("http://", "http://www.")
        });
        return console.log("purged " + (url.replace("http://", "http://www.")));
      }
    };

    WipeMode.prototype.onRedirect = function(details) {
      if (myBlacklist.isBlacklisted(details.redirectUrl, "url") && badRedirects.indexOf(details.redirectUrl)) {
        badRedirects.push(details.url);
        console.log(badRedirects);
      }
      return void 0;
    };

    WipeMode.prototype.wipeHistory = function(startTime, doFullClean) {
      var endTime, maxResults, site, _i, _len, _ref,
        _this = this;
      if (!startTime) {
        startTime = new Date(2000, 0, 1, 0).getTime();
      }
      endTime = new Date().getTime();
      if (doFullClean) {
        _ref = myBlacklist.getBlacklist("urls");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          site = _ref[_i];
          this.purgeBadUrl(site);
        }
      }
      maxResults = 1000000000;
      chrome.history.search({
        text: "",
        startTime: startTime,
        endTime: endTime,
        maxResults: maxResults
      }, function(historyItems) {
        var deleteCount, hItem, nastyRedirect, _j, _k, _len1, _len2;
        deleteCount = 0;
        for (_j = 0, _len1 = historyItems.length; _j < _len1; _j++) {
          hItem = historyItems[_j];
          if (myBlacklist.isBlacklisted(hItem.url, "url") || myBlacklist.isBlacklisted(hItem.title, "keyword")) {
            _this.purgeBadUrl(hItem.url);
            deleteCount++;
          }
          if (hItem.url.indexOf(".google.") >= 0) {
            if (myBlacklist.isBlacklisted(hItem.url, "keyword")) {
              _this.purgeBadUrl(hItem.url);
              deleteCount++;
            }
          }
        }
        for (_k = 0, _len2 = badRedirects.length; _k < _len2; _k++) {
          nastyRedirect = badRedirects[_k];
          chrome.history.deleteUrl({
            url: nastyRedirect
          });
          deleteCount++;
        }
        localStorage["popup_lastCleanupTime"] = JSON.stringify(new Date);
        localStorage["popup_cleanupUrlCounter"] = deleteCount;
        return void 0;
      });
      return void 0;
    };

    return WipeMode;

  })();

  myBlacklist = new MyBlacklist();

  console.log(myBlacklist.getBlacklist("urls"));

  wipeMode = new WipeMode(myBlacklist);

  chrome.tabs.onUpdated.addListener(wipeMode.tabAdded);

  chrome.tabs.onRemoved.addListener(function(tabId, removeInfo) {
    return wipeMode.tabClosed(tabId);
  });

  chrome.extension.onRequest.addListener(function(request, sender, sendResponse) {
    if (request.action === "getAvailableLists") {
      myBlacklist.getAvailableLists(void 0, true);
    } else if (request.action === "changeListState") {
      myBlacklist.setListState(request.listName, request.listState);
      myBlacklist.init();
      wipeMode.wipeHistory(void 0, true);
      console.log(myBlacklist.getBlacklist("urls"));
      console.log(myBlacklist.getBlacklist("keywords"));
    } else if (request.action === "reInit") {
      myBlacklist.init();
      wipeMode.wipeHistory(void 0, true);
    }
    return console.log(request);
  });

  chrome.webRequest.onBeforeRedirect.addListener(wipeMode.onRedirect, {
    urls: ["http://*/*"],
    types: ["main_frame"]
  });

  "chrome.webRequest.onBeforeRequest.addListener(\n  interceptRequest\n  ,{\n  urls: [\"http://*/*\"],\n  types: [\"main_frame\"]\n  },\n  [\"blocking\"]\n)";


}).call(this);
